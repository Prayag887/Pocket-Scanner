package com.example.pocketscanner.data.repository

import android.content.Context
import com.example.pocketscanner.domain.model.Document
import com.example.pocketscanner.domain.model.Page
import com.example.pocketscanner.domain.repository.DocumentRepository
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.flowOn
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileInputStream
import java.io.FileOutputStream
import java.io.ObjectInputStream
import java.io.ObjectOutputStream
import java.io.Serializable

class DocumentRepositoryImpl(private val context: Context) : DocumentRepository {

    private val documentsDir: File by lazy {
        File(context.filesDir, "documents").apply {
            if (!exists()) mkdirs()
        }
    }

    private val metadataDir: File by lazy {
        File(context.filesDir, "metadata").apply {
            if (!exists()) mkdirs()
        }
    }

    override fun getAllDocuments(): Flow<List<Document>> = flow {
        val documents = loadAllDocumentsFromStorage()
        emit(documents)
    }.flowOn(Dispatchers.IO)

    override suspend fun getDocumentById(id: String): Document? = withContext(Dispatchers.IO) {
        val metadataFile = File(metadataDir, "$id.metadata")
        if (!metadataFile.exists()) return@withContext null

        try {
            val documentMetadata = deserializeMetadata(metadataFile) ?: return@withContext null
            val documentDir = File(documentsDir, id)

            if (!documentDir.exists()) return@withContext null

            val pages = documentDir.listFiles()?.mapNotNull { pageFile ->
                val pageId = pageFile.nameWithoutExtension
                val order = pageId.substringAfterLast("_").toIntOrNull() ?: 0
                Page(
                    id = pageId,
                    imageUri = pageFile.absolutePath,
                    order = order
                )
            }?.sortedBy { it.order } ?: emptyList()

            Document(
                id = documentMetadata.id,
                title = documentMetadata.title,
                createdAt = documentMetadata.createdAt,
                pages = pages,
                score = documentMetadata.score
            )
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    override suspend fun saveDocument(document: Document) = withContext(Dispatchers.IO) {
        // Create document directory if it doesn't exist
        val documentDir = File(documentsDir, document.id)
        if (!documentDir.exists()) {
            documentDir.mkdirs()
        }

        // Save metadata
        val documentMetadata = DocumentMetadata(
            id = document.id,
            title = document.title,
            createdAt = document.createdAt,
            score = document.score
        )

        val metadataFile = File(metadataDir, "${document.id}.metadata")
        serializeMetadata(documentMetadata, metadataFile)

        // Process pages
        document.pages.forEach { page ->
            val sourcePath = page.imageUri
            if (sourcePath.isNotEmpty()) {
                val sourceFile = File(sourcePath)
                if (sourceFile.exists()) {
                    val targetFileName = "page_${page.order}.jpg"
                    val targetFile = File(documentDir, targetFileName)

                    // Copy file if it's coming from outside our directory
                    if (sourceFile.absolutePath != targetFile.absolutePath) {
                        sourceFile.inputStream().use { input ->
                            targetFile.outputStream().use { output ->
                                input.copyTo(output)
                            }
                        }
                    }
                }
            }
        }
    }

    override suspend fun deleteDocument(id: String) = withContext(Dispatchers.IO) {
        val documentDir = File(documentsDir, id)
        val metadataFile = File(metadataDir, "$id.metadata")

        // Delete all pages
        if (documentDir.exists()) {
            documentDir.deleteRecursively()
        }

        // Delete metadata
        if (metadataFile.exists()) {
            metadataFile.delete()
        }
    }

    private suspend fun loadAllDocumentsFromStorage(): List<Document> = withContext(Dispatchers.IO) {
        val documents = mutableListOf<Document>()

        metadataDir.listFiles()?.forEach { metadataFile ->
            if (metadataFile.extension == "metadata") {
                val id = metadataFile.nameWithoutExtension
                getDocumentById(id)?.let { document ->
                    documents.add(document)
                }
            }
        }

        // Sort by creation date (newest first)
        documents.sortedByDescending { it.createdAt }
    }

    private fun serializeMetadata(metadata: DocumentMetadata, file: File) {
        try {
            ObjectOutputStream(FileOutputStream(file)).use { outputStream ->
                outputStream.writeObject(metadata)
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun deserializeMetadata(file: File): DocumentMetadata? {
        return try {
            ObjectInputStream(FileInputStream(file)).use { inputStream ->
                inputStream.readObject() as? DocumentMetadata
            }
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    /**
     * Serializable metadata class to store document information
     */
    @Suppress("SerialVersionUIDInSerializableClass")
    data class DocumentMetadata(
        val id: String,
        val title: String,
        val createdAt: Long,
        val score: Int = 0
    ) : Serializable
}