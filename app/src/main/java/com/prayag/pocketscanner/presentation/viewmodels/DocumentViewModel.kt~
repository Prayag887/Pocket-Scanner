package com.prayag.pocketscanner.presentation.viewmodels

import android.content.ContentResolver
import android.content.Context
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.pdf.PdfDocument
import android.graphics.pdf.PdfRenderer
import android.net.Uri
import android.util.Log
import androidx.core.graphics.createBitmap
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.prayag.pocketscanner.domain.model.Document
import com.prayag.pocketscanner.domain.model.Page
import com.prayag.pocketscanner.domain.usecase.GetDocumentsUseCase
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import java.util.Locale
import androidx.core.net.toUri
import kotlinx.coroutines.flow.update
import androidx.collection.LruCache

class DocumentViewModel(
    private val getDocumentsUseCase: GetDocumentsUseCase
) : ViewModel() {

    private val _uiState = MutableStateFlow(DocumentsUiState())
    val uiState: StateFlow<DocumentsUiState> = _uiState.asStateFlow()

    private val _currentFormat = MutableStateFlow("pdf")
    val currentFormat: StateFlow<String> = _currentFormat.asStateFlow()

    private val bitmapCache = LruCache<String, Bitmap>(2)

    init {
        loadDocuments(currentFormat.value)
    }

    fun setCurrentFormat(format: String) {
        if (_currentFormat.value != format) {
            _currentFormat.value = format
            loadDocuments(currentFormat.value)
        }
    }

    fun refreshDocuments() {
        viewModelScope.launch{ loadDocuments(_currentFormat.value) }
    }

    fun getCachedBitmap(key: String): Bitmap? = bitmapCache.get(key)

    fun cacheBitmap(key: String, bitmap: Bitmap) {
        bitmapCache.put(key, bitmap)
    }

    fun deleteDocument(context: Context, fileName: String, onResult: (Boolean) -> Unit = {}) {
        viewModelScope.launch(Dispatchers.IO) {
            val cleanedFileName = fileName.substringBefore("#")
            val file = File(context.filesDir, cleanedFileName)

            val deleted = if (file.exists()) {
                val result = file.delete()
                if (result) {
                    Log.d("Delete", "Successfully deleted file: ${file.path}")
                    _uiState.update { state ->
                        state.copy(documents = state.documents.filterNot { document ->
                            document.pages.any { it.imageUri.contains(cleanedFileName) }
                        })
                    }
                    refreshDocuments()
                } else {
                    Log.e("Delete", "Failed to delete file: ${file.absolutePath}")
                }
                result
            } else {
                Log.w("Delete", "File does not exist: ${file.absolutePath}")
                false
            }

            withContext(Dispatchers.Main) {
                onResult(deleted)
            }
        }
    }

    fun loadDocuments(desiredFormat: String) {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            getDocumentsUseCase(desiredFormat).collect { documents ->
                _uiState.update { it.copy(documents = documents, isLoading = false) }
            }
        }
    }

    fun mergeAndSaveImages(
        uris: List<Uri>,
        contentResolver: ContentResolver,
        filesDir: File,
        fileName: String,
        format: String
    ) {
        viewModelScope.launch {
            try {
                val resultPath = processImages(uris, contentResolver, filesDir, fileName, format)

                if (format.lowercase(Locale.ROOT) == "pdf") {
                    addDocumentFromFile(resultPath)
                } else {
                    val savedUris = resultPath.split(",").map { Uri.fromFile(File(it)) }
                    addDocumentFromFile(resultPath, savedUris)
                }

                _uiState.update { it.copy(error = null, isLoading = true) }
                setCurrentFormat(format)
            } catch (e: Exception) {
                _uiState.update { it.copy(error = e.message) }
            }
        }
    }

    private suspend fun processImages(
        uris: List<Uri>,
        contentResolver: ContentResolver,
        filesDir: File,
        fileName: String,
        format: String
    ): String = withContext(Dispatchers.IO) {
        when (format.lowercase(Locale.ROOT)) {
            "pdf" -> processToPdf(uris, contentResolver, filesDir, fileName)
            "png", "jpg", "jpeg" -> processToImages(uris, contentResolver, filesDir, fileName, format)
            else -> throw IllegalArgumentException("Unsupported format: $format")
        }
    }

    private suspend fun processToPdf(
        uris: List<Uri>,
        contentResolver: ContentResolver,
        filesDir: File,
        fileName: String
    ): String {
        // Check if we can directly use the PDF files
        if (uris.size == 1) {
            val uri = uris.first()
            val mimeType = contentResolver.getType(uri) ?: ""
            if (mimeType == "application/pdf" && uri.scheme == "file") {
                val file = File(uri.path!!)
                if (file.exists()) return file.absolutePath
            }
        }

        // Create new PDF
        val document = PdfDocument()
        var pageIndex = 0

        uris.forEach { uri ->
            extractBitmapsFromUri(uri, contentResolver).forEach { bitmap ->
                pageIndex++
                val pageInfo = PdfDocument.PageInfo.Builder(bitmap.width, bitmap.height, pageIndex).create()
                val page = document.startPage(pageInfo)
                page.canvas.drawBitmap(bitmap, 0f, 0f, null)
                document.finishPage(page)
            }
        }

        val file = File(filesDir, "$fileName.pdf")
        FileOutputStream(file).use { document.writeTo(it) }
        document.close()
        return file.absolutePath
    }

    private suspend fun processToImages(
        uris: List<Uri>,
        contentResolver: ContentResolver,
        filesDir: File,
        fileName: String,
        format: String
    ): String {
        val savedFiles = mutableListOf<String>()
        var fileCounter = 0
        val ext = if (format.lowercase(Locale.ROOT) == "jpeg") "jpg" else format.lowercase(Locale.ROOT)
        val formatEnum = when (ext) {
            "jpg" -> Bitmap.CompressFormat.JPEG
            else -> Bitmap.CompressFormat.PNG
        }

        uris.forEach { uri ->
            extractBitmapsFromUri(uri, contentResolver).forEach { bitmap ->
                fileCounter++
                val imageFile = File(filesDir, "$fileName-$fileCounter.$ext")
                FileOutputStream(imageFile).use { out ->
                    bitmap.compress(formatEnum, 100, out)
                }
                savedFiles.add(imageFile.absolutePath)
            }
        }

        return savedFiles.firstOrNull() ?: throw IllegalStateException("No images saved")
    }

    fun loadDocumentPages(documentId: String, context: Context) {
        viewModelScope.launch {
            try {
                _uiState.update { it.copy(isLoading = true) }

                val document = _uiState.value.documents.find { it.id == documentId }
                    ?: throw IllegalStateException("Document not found")

                when (document.format.lowercase()) {
                    "pdf" -> {} // PDFs are handled differently
                    "png", "jpg", "jpeg" -> {
                        document.pages.forEach { page ->
                            val uri = page.imageUri.toUri()
                            val cacheKey = "${document.id}:${page.order - 1}"

                            if (getCachedBitmap(cacheKey) == null) {
                                try {
                                    val inputStream = when (uri.scheme) {
                                        "file" -> File(uri.path!!).inputStream()
                                        "content" -> context.contentResolver.openInputStream(uri)
                                        else -> null
                                    }

                                    inputStream?.use { stream ->
                                        BitmapFactory.decodeStream(stream)?.let { bitmap ->
                                            cacheBitmap(cacheKey, bitmap)
                                        }
                                    }
                                } catch (e: Exception) {
                                    Log.e("DocumentViewModel", "Error loading image: ${e.message}")
                                }
                            }
                        }
                    }
                    else -> throw IllegalStateException("Unsupported format: ${document.format}")
                }

                _uiState.update { it.copy(isLoading = false, error = null) }
            } catch (e: Exception) {
                _uiState.update { it.copy(isLoading = false, error = "Failed to load document: ${e.message}") }
            }
        }
    }

    private fun extractBitmapsFromUri(uri: Uri, contentResolver: ContentResolver): List<Bitmap> {
        val mimeType = contentResolver.getType(uri) ?: ""

        return when {
            mimeType == "application/pdf" || uri.toString().endsWith(".pdf") -> {
                extractBitmapsFromPdf(uri, contentResolver)
            }
            mimeType.startsWith("image/") || uri.toString().endsWith(".jpg", true) ||
                    uri.toString().endsWith(".jpeg", true) || uri.toString().endsWith(".png", true) -> {
                contentResolver.openInputStream(uri)?.use { stream ->
                    BitmapFactory.decodeStream(stream)?.let { listOf(it) } ?: emptyList()
                } ?: emptyList()
            }
            else -> emptyList()
        }
    }

    private fun extractBitmapsFromPdf(uri: Uri, contentResolver: ContentResolver): List<Bitmap> {
        val bitmaps = mutableListOf<Bitmap>()
        contentResolver.openFileDescriptor(uri, "r")?.use { pfd ->
            PdfRenderer(pfd).use { renderer ->
                for (pageIndex in 0 until renderer.pageCount) {
                    renderer.openPage(pageIndex).use { page ->
                        val bitmap = createBitmap(page.width, page.height)
                        page.render(bitmap, null, null, PdfRenderer.Page.RENDER_MODE_FOR_DISPLAY)
                        bitmaps.add(bitmap)
                    }
                }
            }
        }
        return bitmaps
    }

    fun addDocumentFromFile(filePath: String, pageUris: List<Uri>? = null) {
        val file = File(filePath)
        val documentId = file.nameWithoutExtension
        val extension = file.extension.lowercase(Locale.ROOT)
        val timestamp = System.currentTimeMillis()

        val pages = pageUris?.mapIndexed { index, uri ->
            Page(
                id = "page_${documentId}_$index",
                imageUri = uri.toString(),
                order = index + 1
            )
        } ?: listOf(
            Page(
                id = "page_$documentId",
                imageUri = filePath,
                order = 1
            )
        )

        val document = Document(
            id = documentId,
            title = "Scanned Document $documentId",
            createdAt = timestamp,
            pages = pages,
            format = extension.ifEmpty { "unknown" }
        )

        _uiState.update { it.copy(documents = it.documents + document) }
    }

    fun removeCachedBitmap(key: String) {
        bitmapCache.remove(key)
    }
}

data class DocumentsUiState(
    val documents: List<Document> = emptyList(),
    val isLoading: Boolean = true,
    val isScanning: Boolean = false,
    val error: String? = null
)